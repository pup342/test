- создание локального репозитория (git init (создает репозиторий в выбранном каталоге), git clone <ссылка на удаленный репозиторий> <имя для локального репозитория> (создает копию удаленного репозитория со своим именем (имя можно не вводить)))
- удаление локального репозитория (удалить папку)
- вывести все или определенные параметры конфига (git config --list, git config <имя определенного параметра>)
- узнать статус репозитория (git status, добавить -s для сокращенного вывода статуса)
- начать отслеживать новый файл (git add <name_file>)
- выполнить индексацию (git add <name_file>, git add . (индексация всех изменений)), выполненить частичную индексацию файлов (git add -p), интерактивное индексирование (add -i)
- просмотр неиндексированных изменений (git diff), просмотр индексированных изменений (git diff --staged или --cached)
- припрятывание индексированных и неиндексированных изменений (gis stash), вывод списка припрятанных изменений (git stash list)
	припрятать изменения, но оставить проиндексированные изменения (--keep-index), припрятать также неотслеживаемые файлы (-u)
	припрятать также неотслеживаемые и игнорируемые файлы (-a), припрятать только выбранные изменения (-p)
	применить припрятанные изменения (git stash apply <не добавлять ничего, тогда примениться последние припрятанное изменение> или <name_stash>)
	*по умолчанию все припрятанные изменения восстанавливаются как неиндексированные изменения
	применить припрятанные изменения как индексированные изменения (добавятся, если до припрятывания изменения были индексированы) (--index)
	удалить припрятанные изменения (git stash drop <name_stash>); применить последние припрятанные изменения и тут же удалить их (git stash pop)
	создание ветки из последних припрятанных изменений (git stash branch <name_branch>)
	* создаст новую ветку, перейдёт на коммит, на котором вы были, когда прятали свои наработки, применит на нём эти наработки и затем, если они применились успешно, удалит эти припрятанные изменения
- удаление неотслеживаемых файлов (clean -f); добавить -x для удаления неотслеживаемых и игнорируемых файлов; добавить -d для удаления оставшихся пустых каталогов; добавить -n, чтобы узнать, что будет удалено; добавить -i для перехода в интерактивный режим
	*более безопасным вариантом является использование команды git stash -u для удаления неотслеживаемых файлов или git stash -a для удаления неотслеживаемых и игнорируемых файлов, но с сохранением этого в виде припрятанных изменений
- провести коммит (добавить комментарий через блокнот (и вынести diff в него через -v) или через -m)
- игнорирование индексации при выполнении комита (-a)
- удаление файлов из репозитория (простое удаление из папки и через -rm); удаление индексированного файла -f;
	удаление файла из репозитория, но оставить его на жестком диске (добавить --cached)
- переименование файлов через папку и через -mv
- просмотр изменения текущей или другой ветки (log, log <name_branch>, просмотр изменений всех веток (log --all)
-p, -количество найденных коммитов (цифра), --stat, --author, --committer, --grep, -S,
	-- /путь до файла, название файла (вывод коммитов, где изменялся указанный файл (вводится в самом конце))
- изменение сообщения последнего коммита (commit --amend), добавить новые индексы и выполнить commit --amend (в этом случае перезапишеться
	последний коммит, а не создасться новый); добавить -m, чтобы изменить комментарий к комиту; добавить --no-edit, если не нужно изменять комментарий к коммиту
	*делать только в случае, если история не пострадает (например исправление опечатки, исправление комментария коммита, добавление отслеживаемого файла и т.д.)
	*не делать --amend в опубликованую ветку (работай с ней в локальной, потом пуш в публичный репозиторий)
- отмена индескации файла, отмена изменений в файле (делать через restore!)
- просмотр удаленных репозиториев (-remote, -v), добавление отслеживаемых удаленных репозиториев
- просмотр детальной информации об удаленном репозитории (git remote show)
- загрузка изменений с удаленного сервера на локальный (git fetch)
- замержить свою ветку с другой веткой из основного, удаленного, url репозитория (через fetch и merge)
- автоматически получить изменения из определенной удалённой ветки в указанную локальную ветку (pull)
	(основной, отслеживоемой, url)
	(pull <rep> <name_remote_branch>:<name_local_branch> or <name_new_branch>)
- внести изменения из указанной локальной ветки в определенную удалённую ветку (push)
	(основную, отслеживоемую, url) 
	(push <rep> <name_local_branch>:<name_remote_branch> or <name_new_branch>)
	внести изменения из другой локальной ветки в определенную удаленную ветку 
- переименование удаленного репозитория (remote rename) (переименование идет для локального гита, а не для удаленного)
- удаление удаленного репозитория из отслеживаемых (remote remove) (сам удаленненный репозиторий не удалиться,
	просто перестанет отслеживаться локально)
- просмотр списка тегов (tag), создать аннотированный тег (-a) и легковесный тег (указать только название тега) на последний
	и какой-нибудь старый коммит (через контрольную сумму)
- просмотр подробных сведений о теге и коммите (show)
- отправка одного или всех тегов на удаленный репозиторий (push, --tags) и на локальный (pull)
- удаление тегов с локального (tag -d) и удаленного репозитория (push, --delete) 
	(необходимо удалять теги отдельно и с локального и удаленного репозитория, они не синхронизируются через push или pull)
- получить версии файлов определенного комита или тега
	(git switch <контрольная сумма> или <тег> --detach или checkout <контрольная сумма> или <тег>)
	если необходимо работать с файлами определенного комита или тега, то нужно создать новую ветку и работать в ней
	(git switch -c <new_branch_name> или git checkout -b <name_new_branch>);
	если работать с файлами комита или тега не нужно, то необходимо вернуться обратно на рабочую ветку (git switch -)
- создать новую ветку (branch <new_branch_name> <name_repo>/<branch>), переключится на другую ветку (switch или checkout);
	создать новую ветку и сразу переключиться на нее (git switch -c или git checkout -b <new_branch_name> <rep>/<branch>)
	перед созданием ветки, источником которой является удаленная ветка, нужно выполнить команду fetch (для обновления данных с сервера)
- переключение между ветками (switch or checkout <name_branch>)
- выполнить слияние веток (перейти в ветку, где будет зафиксированно слияние, merge <name_merge_branch>)
	*если при слиянии появится конфликт, то можно вернуть ветку в исходное до слияния состояние (merge --abort)
		*завершиться неудачно она может только в случаях, если перед запуском слияния у вас были не припрятанные или не зафиксированные изменения в рабочем каталоге,
		во всех остальных случаях всё будет хорошо
- объеденить все коммиты из тематической ветки в один коммит (git merge <topicbranch> --squash)
	*после --squash изменения коммитов будут находиться в индексе, необходимо провести коммит для создания одного коммита со всеми изменениями
	*использовать для объединения маленьких коммитов с незначительными изменениями (добавление заголовка, исправление опечатки и т.д.)
- удаление ветки (branch -d)
- вывести список локальных и удаленных веток (branch, --all), вывести последние комиты у всех веток (-v или -vv), 
	вывод замерженных и незамерженных веток относительно текущей и другой ветки (--merged, --no-merged, <name_branch>)
	незамерженные ветки нельзя удалить (можно удалить если использивать опцию -D)
- переименование ветки в локальном и удаленном репозитории  (git branch --move, запушить через -u и удалить ветку со старым названием)
	!
	Не переименовывайте ветки, которые всё ещё используются другими участниками. 
	Не переименовывайте ветку в master/main/mainline, не прочитав раздел «Изменение имени главной ветки».
	!
- добавление удаленной ветки в локальную (git switch or checkout <name_branch>)
- добавление к локальной ветке отслеживаемую удаленную ветку (branch -u <name_repo>/<name_branch>)
	необходимо, чтобы названия были одинаковыми в локальной и удаленной ветке
- выполнение различных команд одна за одной выполняется вводом команд и их отделением знаком ; (пример: git fetch; git branch; и т.д.)
- удаление удаленной ветки (push <name_remote_repo> -d <name_remote_branch>)
- провести перебазирование (rebase <basebranch> или <определенный коммит>); лучше всегда делать перебазирование на последнем коммите, чтобы не было путаницы;
	перед перебазированием лучше выполнить команду git fetch <basebranch>, merge <remote_basebranch>; не делать rebase в опубликованной ветке, создай свою временную и делай там
	выполнить перебазирование ветки <topicbranch> относительно ветки <basebranch> без предварительного переключения на неё:
	git rebase <basebranch> или <определенный коммит> <topicbranch> 
	передать конкретные коммиты в качестве оснований для перебазирования (rebase --onto <basebranch> <topicbranch> <branch>)
	* в этой команде говорится: «Переключись на ветку <basebranch>, найди изменения относительно ветки <topicbranch> и примени их для ветки <branch>
- переместиться на указанный коммит с неиндексированными изменениями (reset <id_commit>)
	*коммиты, которые были внесены после указанного коммита пропадут из истории (можно найти через reflog), все изменения изменения исчезнувших коммитов перенесутся в рабочий каталог (будут неиндексироваными)
	переместиться в указанный коммит с индексированными изменениями (reset --soft <id_commit>)
	*коммиты, которые были внесены после указанного коммита пропадут из истории (можно найти через reflog), все изменения изменения исчезнувших коммитов перенесутся в индекс
	переместиться в указанный коммит без сохранения изменений (reset --hard <id_commit>)
	*коммиты, которые были внесены после указанного коммита пропадут из истории, все изменения изменения исчезнувших коммитов исчезнут
	*если понадобятся коммиты, удаленные из истории, то можно их найти через команду reflog
- восстановление коммита (git revert <sha_commit>)
	*после восстановления история всех коммитов сохранится, но внести те же изменения, которые были внесены после указанного восстанавливаемого коммита будет нельзя,
	гит будет считать, что эти изменения уже есть в истории и их не нужно вносить
	*данную команду лучше использовать для публичного репозитория, т.к. в ней важно сохранить достоверную историю
- определить коммит и автора определенной строки (git blame <name_file>, git blame -L <номер первой строки>,<номер последней строки> <name_file>)
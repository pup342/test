- создание локального репозитория (git init (создает репозиторий в выбранном каталоге), git clone <ссылка на удаленный репозиторий> <имя для локального репозитория> (создает копию удаленного репозитория со своим именем (имя можно не вводить)))
- удаление локального репозитория (удалить папку)
- просмотр удаленных репозиториев (git remote); добавить -v, чтобы просмотреть адреса для чтения и записи; просмотр детальной информации об удаленном репозитории (git remote show <shortname_remote_repo>)
- добавление удаленных репозиториев (git remote add <shortname_remote_repo> <ссылка на удаленный репозиторий>)
- переименование удаленного репозитория (git remote rename <old_shortname_remote_repo> <new_shortname_remote_repo>) (переименование идет для локального гита, а не для удаленного)
- удаление удаленного репозитория (git remote remove <shortname_remote_repo>) (сам удаленненный репозиторий не удалится, просто перестанет отслеживатся локально)
- вывести все или определенные параметры конфига (git config --list, git config <имя определенного параметра>)
- узнать статус репозитория (git status, добавить -s для сокращенного вывода статуса)
- начать отслеживать новый файл (git add <name_file>)
- выполнить индексацию (git add <name_file>, git add . (индексация всех изменений)), выполненить частичную индексацию файлов (git add -p), интерактивное индексирование (add -i)
- просмотр неиндексированных изменений (git diff), просмотр индексированных изменений (git diff --staged или --cached)
- отмена неиндексированных изменений (git restore <name_file>), отмена индесированных изменений (git restore --staged <name_file>)
- припрятывание индексированных и неиндексированных изменений (gis stash), вывод списка припрятанных изменений (git stash list)
	припрятать изменения, но оставить проиндексированные изменения (--keep-index), припрятать также неотслеживаемые файлы (-u)
	припрятать также неотслеживаемые и игнорируемые файлы (-a), припрятать только выбранные изменения (-p)
	применить припрятанные изменения (git stash apply <не добавлять ничего, тогда примениться последние припрятанное изменение> или <name_stash>)
	*по умолчанию все припрятанные изменения восстанавливаются как неиндексированные изменения
	применить припрятанные изменения как индексированные изменения (добавятся, если до припрятывания изменения были индексированы) (--index)
	удалить припрятанные изменения (git stash drop <name_stash>), применить последние припрятанные изменения и тут же удалить их (git stash pop)
	создание ветки из последних припрятанных изменений (git stash branch <name_branch>)
	* создаст новую ветку, перейдёт на коммит, на котором вы были, когда прятали свои наработки, применит на нём эти наработки и затем, если они применились успешно, удалит эти припрятанные изменения
- удаление файлов из репозитория (вручную удалить из папки или через git rm <name_file>); для удаления измененного файла добавить -f; удалить файл из репозитория, но оставить его на жестком диске (добавить --cached)
- удаление неотслеживаемых файлов (clean -f); добавить -x для удаления неотслеживаемых и игнорируемых файлов; добавить -d для удаления оставшихся пустых каталогов; добавить -n, чтобы узнать, что будет удалено; добавить -i для перехода в интерактивный режим
	*более безопасным вариантом является использование команды git stash -u для удаления неотслеживаемых файлов или git stash -a для удаления неотслеживаемых и игнорируемых файлов, но с сохранением этого в виде припрятанных изменений
- переименование файлов вручную через папку или через git mv <old_name_file> <new_name_file>
- провести коммит (git commit), добавить сообщение через открывшийся блокнот или через -m "<текст сообщения>", игнорирование индексации при выполнении коммита (-a)
- изменение сообщения последнего коммита и/или добавление индексированных изменений в предыдущий коммит (git commit --amend) (в этом случае перезапишеться последний коммит, а не создастся новый); добавить --no-edit, если не нужно изменять сообщение к коммиту
	*делать только в случае, если история не пострадает (например исправление опечатки, исправление сообщения коммита, добавление отслеживаемого файла и т.д.)
	*не делать --amend в опубликованую ветку (если коммит уже опубликован, то нужно делать новый коммит, -- amend нужно использовать только для изменений неопубликованных коммитов в локальном репозитории)
- просмотр изменений текущей ветки (git log); просмотр изменений определенной ветки (git log <name_branch>); просмотр изменений всех веток (git log --all)
	добавление -p показывает изменения, внесённые в каждый коммит; количество выводимых коммитов (-<цифра>); вывод сокращенной статистики для коммитов (--stat); вывод коммитов с определенным автором (--author <name_author>); вывод коммитов с определенным коммитером (--committer <name_committer>);
	вывод коммитов с определенным сообщением (--grep <текст_сообщения>); добавление -S <текст_строки> показывает коммиты, в которых изменение повлекло за собой добавление или удаление указанной строки;
	добавление -- <name_file> или path/to/file выводит коммиты, где изменялся указанный файл (вводится в самом конце, *после двойного тире должен быть пробел))
- загрузка изменений с удаленного сервера на локальный (git fetch)
- замержить свою ветку с другой веткой из основного, удаленного, url репозитория (через fetch и merge)
- автоматически получить изменения из определенной удалённой ветки в указанную локальную ветку (pull)
	(основной, отслеживоемой, url)
	(pull <rep> <name_remote_branch>:<name_local_branch> or <name_new_branch>)
- внести изменения из указанной локальной ветки в определенную удалённую ветку (push)
	(основную, отслеживоемую, url) 
	(push <rep> <name_local_branch>:<name_remote_branch> or <name_new_branch>)
	внести изменения из другой локальной ветки в определенную удаленную ветку 
- просмотр списка тегов (tag), создать аннотированный тег (-a) и легковесный тег (указать только название тега) на последний
	и какой-нибудь старый коммит (через контрольную сумму)
- просмотр подробных сведений о теге и коммите (show)
- отправка одного или всех тегов на удаленный репозиторий (push, --tags) и на локальный (pull)
- удаление тегов с локального (tag -d) и удаленного репозитория (push, --delete) 
	(необходимо удалять теги отдельно и с локального и удаленного репозитория, они не синхронизируются через push или pull)
- получить версии файлов определенного комита или тега
	(git switch <контрольная сумма> или <тег> --detach или checkout <контрольная сумма> или <тег>)
	если необходимо работать с файлами определенного комита или тега, то нужно создать новую ветку и работать в ней
	(git switch -c <new_branch_name> или git checkout -b <name_new_branch>);
	если работать с файлами комита или тега не нужно, то необходимо вернуться обратно на рабочую ветку (git switch -)
- создать новую ветку (branch <new_branch_name> <name_repo>/<branch>), переключится на другую ветку (switch или checkout);
	создать новую ветку и сразу переключиться на нее (git switch -c или git checkout -b <new_branch_name> <rep>/<branch>)
	перед созданием ветки, источником которой является удаленная ветка, нужно выполнить команду fetch (для обновления данных с сервера)
- переключение между ветками (switch or checkout <name_branch>)
- выполнить слияние веток (перейти в ветку, где будет зафиксированно слияние, merge <name_merge_branch>)
	*если при слиянии появится конфликт, то можно вернуть ветку в исходное до слияния состояние (merge --abort)
		*завершиться неудачно она может только в случаях, если перед запуском слияния у вас были не припрятанные или не зафиксированные изменения в рабочем каталоге,
		во всех остальных случаях всё будет хорошо
- объеденить все коммиты из тематической ветки в один коммит (git merge <topicbranch> --squash)
	*после --squash изменения коммитов будут находиться в индексе, необходимо провести коммит для создания одного коммита со всеми изменениями
	*использовать для объединения маленьких коммитов с незначительными изменениями (добавление заголовка, исправление опечатки и т.д.)
- удаление ветки (branch -d)
- вывести список локальных и удаленных веток (branch, --all), вывести последние комиты у всех веток (-v или -vv), 
	вывод замерженных и незамерженных веток относительно текущей и другой ветки (--merged, --no-merged, <name_branch>)
	незамерженные ветки нельзя удалить (можно удалить если использивать опцию -D)
- переименование ветки в локальном и удаленном репозитории  (git branch --move, запушить через -u и удалить ветку со старым названием)
	!
	Не переименовывайте ветки, которые всё ещё используются другими участниками. 
	Не переименовывайте ветку в master/main/mainline, не прочитав раздел «Изменение имени главной ветки».
	!
- добавление удаленной ветки в локальную (git switch or checkout <name_branch>)
- добавление к локальной ветке отслеживаемую удаленную ветку (branch -u <name_repo>/<name_branch>)
	необходимо, чтобы названия были одинаковыми в локальной и удаленной ветке
- выполнение различных команд одна за одной выполняется вводом команд и их отделением знаком ; (пример: git fetch; git branch; и т.д.)
- удаление удаленной ветки (push <name_remote_repo> -d <name_remote_branch>)
- провести перебазирование (rebase <basebranch> или <определенный коммит>); лучше всегда делать перебазирование на последнем коммите, чтобы не было путаницы;
	перед перебазированием лучше выполнить команду git fetch <basebranch>, merge <remote_basebranch>; не делать rebase в опубликованной ветке, создай свою временную и делай там
	выполнить перебазирование ветки <topicbranch> относительно ветки <basebranch> без предварительного переключения на неё:
	git rebase <basebranch> или <определенный коммит> <topicbranch> 
	передать конкретные коммиты в качестве оснований для перебазирования (rebase --onto <basebranch> <topicbranch> <branch>)
	* в этой команде говорится: «Переключись на ветку <basebranch>, найди изменения относительно ветки <topicbranch> и примени их для ветки <branch>
- переместиться на указанный коммит с неиндексированными изменениями (reset <id_commit>)
	*коммиты, которые были внесены после указанного коммита пропадут из истории (можно найти через reflog), все изменения изменения исчезнувших коммитов перенесутся в рабочий каталог (будут неиндексироваными)
	переместиться в указанный коммит с индексированными изменениями (reset --soft <id_commit>)
	*коммиты, которые были внесены после указанного коммита пропадут из истории (можно найти через reflog), все изменения изменения исчезнувших коммитов перенесутся в индекс
	переместиться в указанный коммит без сохранения изменений (reset --hard <id_commit>)
	*коммиты, которые были внесены после указанного коммита пропадут из истории, все изменения изменения исчезнувших коммитов исчезнут
	*если понадобятся коммиты, удаленные из истории, то можно их найти через команду reflog
- восстановление коммита (git revert <sha_commit>)
	*после восстановления история всех коммитов сохранится, но внести те же изменения, которые были внесены после указанного восстанавливаемого коммита будет нельзя,
	гит будет считать, что эти изменения уже есть в истории и их не нужно вносить
	*данную команду лучше использовать для публичного репозитория, т.к. в ней важно сохранить достоверную историю
- определить коммит и автора определенной строки (git blame <name_file>, git blame -L <номер первой строки>,<номер последней строки> <name_file>)